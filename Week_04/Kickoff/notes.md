## Resources
- [Lifecycle Visualizer](https://camo.githubusercontent.com/caef5c65f5d34c9409d814a3e81fe0dc039de61c98eb5087369ecf90f4789937/68747470733a2f2f692e6962622e636f2f514e566b6d48432f72656163742d66756e6374696f6e616c2d6c6966656379636c652e706e67)
## Vocab
- **Component Lifecycle** - the series of steps that result in a component being added to the DOM (mounted), any events that result in the component being re-run through an update, and then finally, the process of removing the component from the DOM (unmounting). In essence, the component's lifecycle can be split up into three distinct types of events that lead to the component function being called.
- **useEffect** - a React hook that taps into the various phases of a component lifecycle to run a function at a specified time based on the phase of the component's lifecycle itself. The `useEffect` hook allows us to define the actions that should **only** take place in the following three scenarios:
  1. After the component is first mounted
  2. Whenever a single/set of state values update
  3. When the component is being removed, or unmounted, from the DOM
- **Component Mounting** - The mounting of a component involves React placing the returned HTML into the necessary spot on the DOM, and within class based components, is followed by executing the component's `componentDidMount` method. Within functional React, we don't have `componentDidMount`, but we do have the `useEffect` hook that will allow us to specify some action to be executed upon the initial rendering of a component. Arguably the most common action to take upon a component's mounting is fetching data through an HTTP request. As you'll see in week 12, we can also do things like pulling data from browser-based storage. But don't worry about that yet.
- **Component Updating** - The updating of a component results from the component's state being updated. Any time you call a `setState` function, and a new value is provided, the component updates. A component updating means that the function runs again, but uses any updated values in state in the process. When using class based components, there is a method called `componentDidUpdate`, which runs any time the component updates. Within functional react, the `useEffect` hook is also capable of running some function any time a specific portion of state is detected to have updated. Some examples of using the update aspect of `useEffect` include form validations, checking to see if a user is logged in or not, and in the future, we'll see that it can be used to do things like saving state data to browser's local storage on update.
- **Component Unmounting** - The unmounting of a component is when React is no longer going to be rendering that component. The unmounting of a component could potentially result in memory leaks. For example, say that we were performing some kind of asynchronous action through the use of `setTimeout` or `setInterval`, which runs code after a set amount of time. If, after the initialization of said `setTimeout` or `setInterval`, the component is unmounted, but the timeout or interval function is not cleared, it may continue to run in the background, thus wasting resources. In class based components, there was a method called `componentWillUnmount`, which would be called as a component was being removed from the DOM. As has been the case with the other lifecycle phases, we can also use `useEffect` to declare any **cleanup methods** to be run when a component is being unmounted. 
- **Hooks** - React functions that *hook* into either a component's state or **lifefycle methods**. They allow us to track values that may update between renderings, or even define side effects that should occur after a component render has finished. 
- **Effects** - any events, functions, code, etc. that should run "on the side." They are not intended to occur during every single execution of a function, but can potentially run in reaction to something that happens within the function. 
- **Asynchronous** - in programming, asynchronous code is any code that is not going to be executed in its natural location within the code base. The `setState` function provided by `useState` is actually asynchronous. In code where we wish to perform some operation using the results of asynchronous code, we generally need to use a *promise*.
- **Promise** - promises are used when asynchronous code is used. It is broken down into a few parts. There is the initial promise which accepts a function that should be run. That function should accept two parameters: `resolve` and `reject`. The `resolve` parameter is a function that should run when the promise is considered "kept," as in the result ended up as anticipated. The `reject` function is called when the promise is "broken," either because of some failed condition or a thrown error. When calling a function that is designed as a promise, you have a couple of options as to how you wish to handle these asynchronous methods. You can either use `async/await` (not recommended quite yet), or `.then().catch()` syntax (recommended and will be used for now). The `.then()` call accepts a function that will be run as the `resolve` function of the promise, and the `.catch()` call accepts a function that will be run as the `reject` function of the promise. In short, an asynchronous promise function is called like so:
```js
asyncFunctionName()
  .then((result) => console.log("Function that runs when successful"))
  .catch((error) => console.log("Function that runs when not successful"))
```